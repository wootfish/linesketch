====DESCRIPTION====

This project is built around linesketch.py, a script which takes as
input either a single image or a folder containing images, and for
each input image, generates and saves progressively more detailed
"sketches" of that image, which sketches are done only with straight
lines. The visual effect is striking, and a folder of demo images has
been included to demonstrate this.

On a Bash command line or similar, information about script invocation
may be obtained with by running ./linesketch.py without arguments, or
optionally with the -h argument, as in: ./linesketch.py -h

Standard invocation:
./linesketch.py infile.jpg outfolder

If outfolder does not exist, it will be created. Note that each
iteration spawns eight subprocesses, each of which does lots of math,
and so this script is extremely processor-intensive.


====OVERVIEW====

     linegen.py
Takes an input image and generates progressively more detailed
"sketches" of it using only straight lines.

     linegenlib.py
A library of generator functions for straight, discrete ("aliased")
lines. linegen.py requires linegenlib.py in order to function
correctly.

     demos
A directory of pre-computed outputs, to give a general sense of some
of the things this script can do. Most of the inputs are pictures of
cats.


====DEPENDENCIES====

     Python 2.7 or similar
This code was written for Python 2.7.3. Relatively modern 2.x versions
of Python should be compatible. Python 3.x will not play nice with
these scripts as they currently stand, but since it's < 700 LOC for
both files together, converting them for 3.x compatability doesn't
seem too difficult.

     Pillow
This code uses the Pillow library for Python, which is a fork of the
venerable but long defunct PIL image processing library. The code may
or may not work under vanilla PIL: this is plausible but untested.


====TECHNICAL DETAILS====

The algorithm at work here operates roughly as follows (with some
streamlinings):


 * The command line arguments are parsed, bookkeeping on them is done,
    and the input file is identified. The input file is scaled to
    screen size (hard-coded, currently, as the native resolution of my
    laptop: 1366x768).

 * Next, two 2D "arrays" (i.e. nested lists) of the same size as the
    input image are created. One of these is initialized to all
    0s. This is the "output" data structure. The other (the "source"
    data structure) is initialized to values representing a grayscale
    version of the input image.

 * The program's main idea is to choose random lines within the
    dimensions of both images, then weight these lines according to
    two factors: first, how long they are, and second, how bright the
    single darkest pixel on the line is. Larger weights mean longer,
    brighter lines. The exact balance between these two parameters is
    easy to tweak.

 * After many lines have been generated (in parallel, by the
    afforementioned eight subprocesses) and the best ones have been
    identified, each of these best lines is taken in turn and iterated
    over. This line (which is as bright as the darkest pixel on it) is
    subtracted from the source data structure. At the same time, it is
    added to the output data structure. After this is done many times,
    the "output" will have lots of lines around the brightest parts of
    the image, usually roughly aligned with the image's lines of
    action. The "source" will be the source file minus these lines,
    which is to say it will reflect what has not yet been drawn. Logic
    is used to ensure that drawn lines don't overlap, since overlaps &
    repeated subtractions could introduce negative values into the
    "source" and cause trouble to a spectacular degree.

 * Iterating these last two bullet points repeatedly produces
    increasingly accurate sketches. At regular intervals (default:
    every 150 lines, customizable by the -i command-line flag), the
    script will save, in seperate, automatically created subfolders,
    both the grayscale sketch and a color sketch generated by using
    the grayscale sketch as a mask over the original full-color image.

 * The program will run indefinitely, and should be terminated using
    Ctrl-C.

====FUTURE PLANS====

This is a list of things I am planning on adding or changing, as free
time allows:


 * Ability to compile iterations into an animated .gif

   Pillow/PIL does not natively support animated GIFs, so doing this
   in a way that has cross-platform portability is harder than it
   sounds. There is tons of Linux software that can be used, but to
   implement this so that it runs under Windows (which is a priority)
   looks like it might require writing a custom library. The format
   specification is freely available online, and so writing this
   custom library and using it to implement a standalone script that
   compiles linesketch.py output into an animated GIF is next up in my
   plan for this project.


 * True support for generating "color" images

   Previous attempts to do this ended up looking awful and impacting
   performance in a big way, so the idea got dropped. Recently,
   though, I've been considering several ways to implement this
   function which could create interesting effects. If I get bored
   some evening after the .gif feature is done, I'll likely try some
   of these ideas out and see how they look.


 * Implementing the -p flag

   The multiprocessing library has support for various features, most
   notably pools, which make me believe that this is entirely
   possible. However, much like the bullet point below, the difficulty
   of implementing this feature is disproportionately significant
   relative to its usefulness, and so it is a low priority. It also
   seems not improbable, from some old experiments, that performance
   could take a non-negligible blow from this change, and keeping
   performance strong is a high priority.
   
   
 * Automatic detection of native screen resolution for use in scaling
 
   I don't know what sort of support Python has for this, but it's a
   minor improvement and it doesn't sound easy, so this is a low
   priority.


